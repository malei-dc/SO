Práctica 5: Entrada/Salida

1) Concepto Driver
    ¿Cuáles de las siguientes opciones describen el concepto de driver? Seleccione las correctas y justifique.
    
    (a) Es una pieza de software. 
        Correcto. Un driver es un programa de software que permite al sistema operativo y a otros programas interactuar con el hardware. Los drivers 
        actúan como traductores entre el dispositivo hardware y el Kernel.

    (b) Es una pieza de hardware.
        Incorrecto. Un driver es software, no hardware.

    (c) Es parte del SO.
        Correcto. Los drivers son generalmente componentes del sistema operativo, ya que están integrados o cargados por el sistema operativo para 
        gestionar la comunicación con el hardware. Sin embargo, no son parte del núcleo del sistema operativo en sí, pero sí son esenciales para la 
        operación de muchos dispositivos.

    (d) Dado que el usuario puede cambiarlo, es una aplicación de usuario.
        Incorrecto. Aunque los usuarios pueden instalar o actualizar drivers, estos no son considerados aplicaciones de usuario, ya que no son programas 
        que los usuarios finales ejecuten directamente para realizar tareas. Los drivers funcionan en un nivel más bajo para facilitar la comunicación 
        entre el hardware y el software del sistema.

    (e) Es un gestor de interrupciones.
        Incorrecto. Aunque los drivers pueden manejar interrupciones generadas por el hardware, no son gestores de interrupciones per se. Los gestores de 
        interrupciones son componentes específicos del sistema operativo que manejan la asignación y la respuesta a las interrupciones.

    (f) Tiene conocimiento del dispositivo que controla pero no del SO en el que corre.
        Incorrecto. Los drivers deben tener conocimiento del sistema operativo para poder funcionar correctamente, ya que necesitan interactuar con él 
        para realizar tareas como la gestión de memoria, la comunicación con el hardware, y la implementación de políticas de seguridad.

    (g) Tiene conocimiento del SO en el que corre y del tipo de dispositivo que controla, pero no de las particularidades del modelo específico.
        Correcto. Un driver tiene que ser consciente del sistema operativo en el que se está ejecutando para poder interactuar correctamente con él y 
        debe conocer cómo controlar el tipo de dispositivo para el que fue diseñado. Sin embargo, los drivers están usualmente diseñados para ser genéricos 
        respecto a las particularidades del modelo específico de un dispositivo, aunque en algunos casos pueden tener optimizaciones específicas.

2) Cronómetro
    Un cronómetro posee 2 registros de E/S:
    - CHRONO_CURRENT_TIME que permite leer el tiempo medido,
    - CHRONO_CTRL que permite ordenar al dispositivo que reinicie el contador.
    El cronómetro reinicia su contador escribiendo la constante CHRONO_RESET en el registro de control.
    Escribir un driver para manejar este cronómetro. Este driver debe devolver el tiempo actual cuando invoca la operación read(). 
    Si el usuario invoca la operación write(), el cronómetro debe reiniciarse.

    int main (int argc, char *argv[]) {
        int crono = open("/dev/crono", "w");
        char *respuesta[2];
        int reinicio;
        while (1) {
            printf("Desea reiniciar el cronometro? SI/NO\n");
            scanf ("%s", &respuesta);
            if (respuesta == "SI") {
                reinicio = write()
            }
            else 
                reinicio = read()


            if (reinicio == 1){
                printf("Cronómetro reiniciado\n");
            }
            else {
                printf("Tiempo actual: %s\n", reinicio);
            }
        }
    }//-------------------------------hace falta escribir la funcion main? ------------------------------------

    semaphore mutex;

    int driver_init() {
        mutex = sem(1);
        return ??;          //duda que pongo de return en estas funciones?
    }

    int driver_read(int* udata) {
        mutex.wait();
        int time = IN(CHRONO_CURRENT_TIME);
        copy_to_user(udata, &time, sizeof(time));
        mutex.signal();
        return ??;
    }

    int driver_write(int* udata) {
        mutex.wait();
        OUT(CHRONO_CTRL, CHRONO_RESET);
        OUT(CHRONO_CURRENT_TIME, 0);
        mutex.signal();
        return ??;
    }

3) Boton
    Una tecla posee un único registro de E/S : 
        BTN_STATUS. Solo el bit menos significativo y el segundo bit menos significativo son de interés:
            -BTN_STATUS0 : vale 0 si la tecla no fue pulsada, 1 si fue pulsada.
            -BTN_STATUS1 : escribir 0 en este bit para limpiar la memoria de la tecla.
    Escribir un driver para manejar este dispositivo de E/S. El driver debe retornar la constante BTN_PRESSED cuando se presiona la tecla. 
    Usar busy waiting.

    int driver_init() {
        mutex = sem(1);
        return ??;          
    }

    int driver_write(int *udata) {
        mutex.wait();
        int statos;
            // Busy-waiting hasta que el bit menos significativo sea 1.
        while ((statos = IN(BTN_STATUS)) and 1 != 0)
            // Reseteamos el estado de la tecla.
        OUT(BTN_STATUS, pongoElBit1En0(status));
        mutex.signal();

        int result = BTN_PRESSED;
        copy_to_user(udata, &result, sizeof(result));
        
        return ??;
    }

4) Boton con interrupción
    Reescribir el driver del ejercicio anterior para que utilice interrupciones en lugar de busy waiting.
    Para ello, aprovechar que la tecla ha sido conectada a la línea de interrupción número 7.
    Para indicar al dispositivo que debe efectuar una nueva interrupción al detectar una nueva pulsación
    de la tecla, debe guardar la constante BTN_INT en el registro de la tecla.

    int driver_init() {
        mutex = sem(1);
        presionado = sem(0);
        irq_register(7, handler)

        // Reseteamos el estado de la tecla para que mande la primer interrupción.
        OUT(BTN_STATUS, BTN_INT);

        return ??;          
    }

    void handler() {
        presionado.signal();
    }

    int driver_remove() {
        free_irq(7);
        return ??;
    }

    int driver_write(int *udata) {
        // Esperamos el mutex para tener uso exclusivo de la tecla.
        mutex.wait();

        // Esperamos la señal de que la tecla fue presionada.
        presionado.wait();

        OUT(BTN_STATUS, BTN_INT);

        mutex.signal();

        // Avisamos al usuario que se presionó la tecla.
        int result = BTN_PRESSED;
        copy_to_user(udata, &result, sizeof(result));
        
        return ??;
    }

5) Open - write
    Indicar las acciones que debe tomar el administrador de E/S:
    (a) cuando se efectúa un open().
        - Comprobar si el archivo o dispositivo solicitado existe y es accesible.
        - Inicializar cualquier estado necesario para la operación del archivo o dispositivo. Esto puede incluir buffers de E/S, bloques de control, 
        handler de interrupciones, etc.
        - Verificar que el usuario tiene los permisos adecuados (lectura, escritura, ejecución) para acceder al archivo o dispositivo solicitado.
        - Actualizar las tablas de archivos abiertos y otras estructuras internas del sistema operativo para reflejar el nuevo archivo o dispositivo 
        abierto.

    (b) cuando se efectúa un write().
        - Comprobar que el descriptor de archivo proporcionado es válido y corresponde a un archivo o dispositivo abierto en modo de escritura.
        - Verificar que el usuario tiene permisos de escritura para el archivo o dispositivo.
        - Copiar los datos que se van a escribir desde el espacio de usuario (la memoria del proceso que llamó a write()) al espacio de memoria del 
        kernel, donde el sistema operativo puede procesarlos de manera segura.
        - Realizar la escritura física de los datos en el archivo o dispositivo. Esto puede implicar la actualización de los bloques de datos en un 
        sistema de archivos o la transmisión de datos a través de un dispositivo de red o un dispositivo de almacenamiento.
        - Actualizar la posición actual en el archivo o dispositivo para reflejar los datos escritos. Esto permite que las subsecuentes operaciones de 
        E/S continúen desde la posición correcta.

6) IN - OUT
    ¿Cuál debería ser el nivel de acceso para las syscalls IN y OUT? ¿Por qué?
        Las syscalls IN y OUT se ejecutan en nivel kernel porque acceden de forma directa a los registros de los dispositivos de hardware. 
        De esta forma un programa de usuario malicioso o mal implementado no puede acceder directamente a los dispositivos, necesita pasar por un 
        driver, permitiendo así que el SO aplique los mecanismos de protección y seguridad. Por ejemplo, el programa de usuario necesita tener los 
        permisos suficientes para hacerle open al driver.

7) Discos ópticos
    Se desea implementar el driver de una controladora de una unidad de discos ópticos que requiere controlar manualmente el motor de la misma. 
    Esta controladora posee 3 registros de lectura y 3 de escritura. 

    Los registros de escritura son:
        - DOR_IO: enciende (escribiendo 1) o apaga (escribiendo 0) el motor de la unidad.
        - ARM: número de pista a seleccionar.
        - SEEK_SECTOR: número de sector a seleccionar dentro de la pista.
    Los registros de lectura son:
        - DOR_STATUS: contiene el valor 0 si el motor está apagado (o en proceso de apagarse), 1 si está encendido. 
        Un valor 1 en este registro no garantiza que la velocidad rotacional del motor sea la suficiente como para realizar exitosamente una 
        operación en el disco.
        - ARM_STATUS: contiene el valor 0 si el brazo se está moviendo, 1 si se ubica en la pista indicada en el registro ARM.
        - DATA_READY: contiene el valor 1 cuando el dato ya fue enviado.
    Además, se cuenta con las siguientes funciones auxiliares (ya implementadas):
        - int cantidad_sectores_por_pista(): Devuelve la cantidad de sectores por cada pista del disco. El sector 0 es el primer sector de la pista.
        - void escribir_datos(void *src): Escribe los datos apuntados por src en el último sector seleccionado.
        - void sleep(int ms): Espera durante ms milisegundos.
        
    Antes de escribir un sector, el driver debe asegurarse que el motor se encuentre encendido. Si no lo está, debe encenderlo, y para garantizar 
    que la velocidad rotacional sea suficiente, esperar al menos 50 ms antes de realizar cualquier operación. 
    A su vez, para conservar energía, una vez qwriteue finalice una operación en el disco, el motor debe ser apagado. El proceso de apagado demora como
    máximo 200 ms, tiempo antes del cual no es posible comenzar nuevas operaciones.

    (a) Implementar la función write(int sector, void *data) del driver, que escriba los datos apuntados por data en el sector en formato LBA 
    (es decir, que los sectores son numerados según un índice, empezando por cero) indicado por sector. Para esta primera implementación, no usar
    interrupciones.

    write(int sector, void *data) {
        mutex.wait()
        int uSector;
        copy_from_user(&uSector, sector, sizeof(int));

        //calculo pista y sector que se van a escribir en los registros de escritura.
        int pista = divisionParteEntera(uSector, cantidad_sectores_por_pista())
        uSector = uSector % cantidad_sectores_por_pista();

        //me aseguro que el motor este encendido
        if (!IN(DOR_STATUS))
            OUT(DOR_IO, 1)              //si motor estaba apagado encender
        sleep(55);                      //en cualquier caso esperar 55ms para asegurar velocidad

        //insertamos datos
        OUT(ARM, pista);
        OUT(SEEK_SECTOR, uSector);

        //esperamos a que encuentre pista
        while(!IN(ARM_STATUS)) {}

        //escribimos data
        int datos
        copy_from_user(&datos, data, sizeof(int))
        escribir_datos(*datos);

        //esperamos a que termine la escritura
        while(!IN(DATA_READY)) {}

        OUT(DOR_IO, 0);
        sleep(200);
        mutex.signal()
    }


