Práctica 5: Entrada/Salida

1) Concepto Driver
    ¿Cuáles de las siguientes opciones describen el concepto de driver? Seleccione las correctas y justifique.
    
    (a) Es una pieza de software. 
        Correcto. Un driver es un programa de software que permite al sistema operativo y a otros programas interactuar con el hardware. Los drivers 
        actúan como traductores entre el dispositivo hardware y el Kernel.

    (b) Es una pieza de hardware.
        Incorrecto. Un driver es software, no hardware.

    (c) Es parte del SO.
        Correcto. Los drivers son generalmente componentes del sistema operativo, ya que están integrados o cargados por el sistema operativo para 
        gestionar la comunicación con el hardware. Sin embargo, no son parte del núcleo del sistema operativo en sí, pero sí son esenciales para la 
        operación de muchos dispositivos.

    (d) Dado que el usuario puede cambiarlo, es una aplicación de usuario.
        Incorrecto. Aunque los usuarios pueden instalar o actualizar drivers, estos no son considerados aplicaciones de usuario, ya que no son programas 
        que los usuarios finales ejecuten directamente para realizar tareas. Los drivers funcionan en un nivel más bajo para facilitar la comunicación 
        entre el hardware y el software del sistema.

    (e) Es un gestor de interrupciones.
        Incorrecto. Aunque los drivers pueden manejar interrupciones generadas por el hardware, no son gestores de interrupciones per se. Los gestores de 
        interrupciones son componentes específicos del sistema operativo que manejan la asignación y la respuesta a las interrupciones.

    (f) Tiene conocimiento del dispositivo que controla pero no del SO en el que corre.
        Incorrecto. Los drivers deben tener conocimiento del sistema operativo para poder funcionar correctamente, ya que necesitan interactuar con él 
        para realizar tareas como la gestión de memoria, la comunicación con el hardware, y la implementación de políticas de seguridad.

    (g) Tiene conocimiento del SO en el que corre y del tipo de dispositivo que controla, pero no de las particularidades del modelo específico.
        Correcto. Un driver tiene que ser consciente del sistema operativo en el que se está ejecutando para poder interactuar correctamente con él y 
        debe conocer cómo controlar el tipo de dispositivo para el que fue diseñado. Sin embargo, los drivers están usualmente diseñados para ser genéricos 
        respecto a las particularidades del modelo específico de un dispositivo, aunque en algunos casos pueden tener optimizaciones específicas.

2) Cronómetro
    Un cronómetro posee 2 registros de E/S:
    - CHRONO_CURRENT_TIME que permite leer el tiempo medido,
    - CHRONO_CTRL que permite ordenar al dispositivo que reinicie el contador.
    El cronómetro reinicia su contador escribiendo la constante CHRONO_RESET en el registro de control.
    Escribir un driver para manejar este cronómetro. Este driver debe devolver el tiempo actual cuando invoca la operación read(). 
    Si el usuario invoca la operación write(), el cronómetro debe reiniciarse.

    int main (int argc, char *argv[]) {
        int crono = open("/dev/crono", "w");
        char *respuesta[2];
        int reinicio;
        while (1) {
            printf("Desea reiniciar el cronometro? SI/NO\n");
            scanf ("%s", &respuesta);
            if (respuesta == "SI") {
                reinicio = write()
            }
            else 
                reinicio = read()


            if (reinicio == 1){
                printf("Cronómetro reiniciado\n");
            }
            else {
                printf("Tiempo actual: %s\n", reinicio);
            }
        }
    }//-------------------------------hace falta escribir la funcion main? ------------------------------------

    semaphore mutex;

    int driver_init() {
        mutex = sem(1);
        return ??;          //duda que pongo de return en estas funciones?
    }

    int driver_read(int* udata) {
        mutex.wait();
        int time = IN(CHRONO_CURRENT_TIME);
        copy_to_user(udata, &time, sizeof(time));
        mutex.signal();
        return ??;
    }

    int driver_write(int* udata) {
        mutex.wait();
        OUT(CHRONO_CTRL, CHRONO_RESET);
        OUT(CHRONO_CURRENT_TIME, 0);
        mutex.signal();
        return ??;
    }

3) Boton
    Una tecla posee un único registro de E/S : 
        BTN_STATUS. Solo el bit menos significativo y el segundo bit menos significativo son de interés:
            -BTN_STATUS0 : vale 0 si la tecla no fue pulsada, 1 si fue pulsada.
            -BTN_STATUS1 : escribir 0 en este bit para limpiar la memoria de la tecla.
    Escribir un driver para manejar este dispositivo de E/S. El driver debe retornar la constante BTN_PRESSED cuando se presiona la tecla. 
    Usar busy waiting.

    int driver_init() {
        mutex = sem(1);
        return ??;          
    }

    int driver_write(int *udata) {
        mutex.wait();
        int statos;
            // Busy-waiting hasta que el bit menos significativo sea 1.
        while ((statos = IN(BTN_STATUS)) and 1 != 0)
            // Reseteamos el estado de la tecla.
        OUT(BTN_STATUS, pongoElBit1En0(status));
        mutex.signal();

        int result = BTN_PRESSED;
        copy_to_user(udata, &result, sizeof(result));
        
        return ??;
    }

4) Boton con interrupción
    Reescribir el driver del ejercicio anterior para que utilice interrupciones en lugar de busy waiting.
    Para ello, aprovechar que la tecla ha sido conectada a la línea de interrupción número 7.
    Para indicar al dispositivo que debe efectuar una nueva interrupción al detectar una nueva pulsación
    de la tecla, debe guardar la constante BTN_INT en el registro de la tecla.

    int driver_init() {
        mutex = sem(1);
        presionado = sem(0);
        irq_register(7, handler)

        // Reseteamos el estado de la tecla para que mande la primer interrupción.
        OUT(BTN_STATUS, BTN_INT);

        return ??;          
    }

    void handler() {
        presionado.signal();
    }

    int driver_remove() {
        free_irq(7);
        return ??;
    }

    int driver_write(int *udata) {
        // Esperamos el mutex para tener uso exclusivo de la tecla.
        mutex.wait();

        // Esperamos la señal de que la tecla fue presionada.
        presionado.wait();

        OUT(BTN_STATUS, BTN_INT);

        mutex.signal();

        // Avisamos al usuario que se presionó la tecla.
        int result = BTN_PRESSED;
        copy_to_user(udata, &result, sizeof(result));
        
        return ??;
    }
